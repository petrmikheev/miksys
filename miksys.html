<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>MIKSYS doc</title>
        <style>
            a { color: blue }
        </style>
    </head>
    <body>
        <h2>Введение</h2>
        <p>
            MIKSYS &mdash; это SoC, разработанная для платы <a href="http://marsohod.org/prodmarsohod2">Марсоход2</a> с ПЛИС Altera Cyclone III.<br/>
            Работа выполнена для получения опыта разработки на verilog. Практической ценности не имеет.<br/>
            Была поставлена цель выжать из платы производительность, достаточную для отображения 3д графики.<br/>
            Рабочая частота 108MHz.
        </p>
        <img src="miksys.png" />
        <ul style="width:900px">
            <li>Архитектура относится к классу SIMD.
            Исполняющие блоки PU0 - PU3 одновременно выполняют одну и ту же команду с разными наборами данных.</li>
            <li>Архитектура 16-битная. Размер любого регистра, ячейки кэша, ячейки памяти - 16 бит. Команды занимают по 2 ячейки &mdash; 32 бита. В блоках PU0 - PU3 реализована целочисленная 16-битная арифметика.</li>
<!--            <li>В блоках FPU реализована арифметика с плавающей точкой одинарной точности (32 бита). К каждому FPU подключены два PU. Младшие 16 бит каждого параметра берутся из PU0/PU2, cтаршие 16 бит берутся из PU1/PU3. <span style="color:#d55">Блоки FPU были отключены из за недостатка ресурсов ПЛИС, на схеме показаны серым.</span></li>-->
            <li>Отсутствует прямой обмен данными между исполняющими блоками и оперативной памятью. Обмен между кэшем и оперативной памятью осуществляется явно, командами READ и WRITE. Исполняющие блоки могут одновременно обращаться только к группе из 4 последовательных ячеек в кэше.</li>
            <li>Блок PU0 является основным. Только он может использовать порты ввода-вывода, менять указатель команд, задавать адрес для обращения к кэшу и т.д. Также только блок PU0 может менять общие для всех PU регистры R8-R15.</li>
            <li>С целью увеличения производительности были приняты некоторые решения, уменьшающие удобство программирования. Например, есть команды переходов, после которых не сбрасывается конвеер команд. Это значит, что после перехода еще 4 команды будут выполнены со старого места. <a href="#details">Ниже</a> приведен список подобных неочевидных особенностей.</li>
        </ul>
        <h2>Содержание</h2>
        <ul>
            <li><a href="#commands">Система команд</a></li>
            <li><a href="#regs">Регистры</a></li>
            <li><a href="#suffix">Суффиксы условного выполнения</a></li>
            <li><a href="#command_details">Форматы команд</a></li>
            <li><a href="#asm">Синтаксис ассемблера</a></li>
            <li><a href="#bootloader">Загрузчик</a></li>
            <li><a href="#details">Некоторые особенности</a></li>
            <li><a href="#examples">Примеры</a></li>
        </ul>
        <h2 id="commands">Система команд</h2>
        <table>
            <tr>
                <th>Opcode</th>
                <th>Name</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>0x00</td>
                <td><a href="#c_NOP">NOP</a></td>
                <td>Пропуск такта</td>
            </tr>
            <tr>
                <td>0x01</td>
                <td><a href="#c_J">J</a></td>
                <td>Переход по адресу (без сброса конвеера)</td>
            </tr>
            <tr>
                <td>0x01</td>
                <td><a href="#c_J">CALL</a></td>
                <td>Вызов функции (без сброса конвеера)</td>
            </tr>
            <tr>
                <td>0x01</td>
                <td><a href="#c_J">RET</a></td>
                <td>Возврат из функции (также используется для перехода по абсолютному адресу; без сброса конвеера)</td>
            </tr>
            <tr>
                <td>0x02</td>
                <td><a href="#c_CMOV">CMOV</a></td>
                <td>Запись константы в регистр или спец. регистр</td>
            </tr>
            <tr>
                <td>0x03</td>
                <td><a href="#c_CCMOV">CCMOV</a></td>
                <td>Запись константы в кэш</td>
            </tr>
<!--            <tr>-->
<!--                <td>00100</td>-->
<!--                <td><a href="#c_FPU">FPMODE</a></td>-->
<!--                <td style="color: #888">Изменение параметров FPU (блоки FPU отключены)</td>-->
<!--            </tr>-->
            <tr>
                <td>0x05</td>
                <td><a href="#c_DJ">DJ</a></td>
                <td>Переход по адресу со сбросом конвеера</td>
            </tr>
            <tr>
                <td>0x05</td>
                <td><a href="#c_DJ">DCALL</a></td>
                <td>Вызов функции со сбросом конвеера</td>
            </tr>
            <tr>
                <td>0x05</td>
                <td><a href="#c_DJ">DRET</a></td>
                <td>Возврат из функции со сбросом конвеера (также используется для перехода по абсолютному адресу)</td>
            </tr>
<!--            <tr>-->
<!--                <td>01011</td>-->
<!--                <td><a href="#c_FPU">FPDATA</a></td>-->
<!--                <td style="color: #888">Передача данных в FPU (блоки FPU отключены)</td>-->
<!--            </tr>-->
            <tr>
                <td>0x0C</td>
                <td><a href="#c_MUL">SHL</a></td>
                <td>Битовый сдвиг влево. Результат сохраняется в спец. регистр.</td>
            </tr>
            <tr>
                <td>0x0C</td>
                <td><a href="#c_MUL">SHR</a></td>
                <td>Битовый сдвиг в право. Результат сохраняется в спец. регистр.</td>
            </tr>
            <tr>
                <td>0x0D</td>
                <td><a href="#c_MUL">MUL</a></td>
                <td>Беззнаковое умножение. Результат сохраняется в спец. регистры.</td>
            </tr>
            <tr>
                <td>0x0D</td>
                <td><a href="#c_WMUL">WMUL</a></td>
                <td>Двойное умножение (32bit x 16bit) с отбрасыванием младших 16bit. Результат сохраняется в спец. регистры.</td>
            </tr>
            <tr>
                <td>0x0E</td>
                <td><a href="#c_MUL">SMUL</a></td>
                <td>Умножение со знаком (доступно только в PU0). Результат сохраняется в спец. регистры.</td>
            </tr>
            <tr>
                <td>0x0F</td>
                <td><a href="#c_RW">READ</a></td>
                <td>Чтение блока данных из оперативной памяти в кэш</td>
            </tr>
            <tr>
                <td>0x0F</td>
                <td><a href="#c_RW">WRITE</a></td>
                <td>Запись блока данных из кэша в оперативную память</td>
            </tr>
            <tr>
                <td>0x10</td>
                <td><a href="#c_arith">OR</a></td>
                <td>Побитовое ИЛИ</td>
            </tr>
            <tr>
                <td>0x11</td>
                <td><a href="#c_arith">XOR</a></td>
                <td>Побитовое исключающее ИЛИ</td>
            </tr>
            <tr>
                <td>0x12</td>
                <td><a href="#c_arith">AND</a></td>
                <td>Побитовое И</td>
            </tr>
            <tr>
                <td>0x13</td>
                <td><a href="#c_CMP">TST</a></td>
                <td>Побитовое И без сохранения результата (меняются толко флаги)</td>
            </tr>
            <tr>
                <td>0x14</td>
                <td><a href="#c_MOV">MOV</a></td>
                <td>Копирование значения из регистра в регистр или между регистром и кэшем</td>
            </tr>
            <tr>
                <td>0x14</td>
                <td><a href="#c_IO">IN</a></td>
                <td>Чтение из порта ввода-вывода. Не может быть условным.</td>
            </tr>
            <tr>
                <td>0x14</td>
                <td><a href="#c_IO">OUT</a></td>
                <td>Запись в порт ввода-вывод. Не может быть условным.</td>
            </tr>
            <tr>
                <td>0x15</td>
                <td><a href="#c_LPU">LPU0-LPU3</a></td>
                <td style="color: #888">Загрузка из кэша в конкретный PU (не реализовано)</td>
            </tr>
            <tr>
                <td>0x16</td>
                <td><a href="#c_arith">RGBADD</a></td>
                <td>Сложение двух цветов в формате R5G6B5</td>
            </tr>
            <tr>
                <td>0x17</td>
                <td><a href="#c_arith">RGBSHR</a></td>
                <td>Сдвиг на 1 бит вправо цвета в формате R5G6B5 (яркость уменьшается в 2 раза). Двухадресная команда.</td>
            </tr>
            <tr>
                <td>0x18</td>
                <td><a href="#c_arith">ADD</a></td>
                <td>Сложение</td>
            </tr>
            <tr>
                <td>0x19</td>
                <td><a href="#c_arith">RSB</a></td>
                <td>Обратное вычитание (меняется порядок операндов)</td>
            </tr>
            <tr>
                <td>0x1A</td>
                <td><a href="#c_arith">SUB</a></td>
                <td>Вычитание</td>
            </tr>
            <tr>
                <td>0x1B</td>
                <td><a href="#c_CMP">CMP</a></td>
                <td>Сравнение (вычитание без сохранения результата)</td>
            </tr>
            <tr>
                <td>0x1C</td>
                <td><a href="#c_arith">ADС</a></td>
                <td>Сложение с учетом переноса в предыдущей команде</td>
            </tr>
            <tr>
                <td>0x1D</td>
                <td><a href="#c_arith">RSС</a></td>
                <td>Обратное вычитание с учетом переноса в предыдущей команде</td>
            </tr>
            <tr>
                <td>0x1E</td>
                <td><a href="#c_arith">SBС</a></td>
                <td>Вычитание с учетом переноса в предыдущей команде</td>
            </tr>
        </table>
        <h2 id="regs">Регистры</h2>
        Существует 16 регистров общего назначения R0-R15.<br/>
        R0-R7 свои у каждого PU. R8-R15 &ndash; общие, но могут меняться только из PU0. Если все PU выполнят команду "MOV R8, R1", то в R8 окажется значение R1 из PU0, независимо от R1 в других PU.
        <h3>Специальные регистры</h3>
        У разных PU спец. регистры разные. Некоторые спец. регистры есть только у PU0.
        <table>
            <tr><th colspan="3">Специальные регистры, доступные для чтения</th></tr>
            <tr><th>Номер</th><th>Название</th><th>Описание</th></tr>
            <tr><td>0</td><td>IN_FLAGS</td><td><a href="#in_flags">Регистр состояния</a></td></tr>
            <tr><td>1</td><td>MEM_ADDR_LO</td><td>Младшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)</td></tr>
            <tr><td>2</td><td>MEM_ADDR_HI</td><td>Старшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)</td></tr>
            <tr><td>3</td><td>IN_CLOCK</td><td>Счетчик тактов (только в PU0)</td></tr>
            <tr><td>4</td><td>IN_TIME_MS4</td><td>Счетчик, увеличивающися 4000 раз в секунду (только в PU0)</td></tr>
            <tr><td>5</td>
                <td>MUL_RESULT_LO<br/>SHIFT_RESULT</td>
                <td>
                    Результат целочисленного умножения, младшие 16 бит<br/>
                    Результат сдвиговой операции (SHL или SHR)<br/>
                </td></tr>
            <tr><td>6</td>
                <td>MUL_RESULT_HI</td>
                <td>Результат целочисленного умножения, старшие 16 бит</td>
            </tr>
<!--            <tr><td>7</td><td>FLOAT_RESULT</td><td>Результат операции с плавающей точкой</td></tr>-->
            <tr><th colspan="3">Специальные регистры, доступные для записи</th></tr>
            <tr><th>Номер</th><th>Название</th><th>Описание</th></tr>
            <tr><td>0</td><td>OUT_LEDS</td><td>Младшие 4 бита управляются состоянием светодиодов на плате (только в PU0)</td></tr>
            <tr><td>1</td><td>MEM_ADDR_LO</td><td>Младшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)</td></tr>
            <tr><td>2</td><td>MEM_ADDR_HI</td><td>Старшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)</td></tr>
        </table>
        <h3 id="in_flags">Регистр состояния IN_FLAGS</h3>
        Формат (по битам, от старших к младшим): 0000 0000 CVZN mbPP
        <ul>
            <li>PP &mdash; номер текущего PU</li>
            <li>m &mdash; 1 если в данный момент в фоне выполняется операция с оперативной памятью</li>
            <li>b &mdash; 1 если нажата кнопка на плате</li>
            <li>С &mdash; Carry flag, 1 если был перенос из старшего разряда</li>
            <li>V &mdash; Overflow flag, 1 если было знаковое переполнение</li>
            <li>Z &mdash; Zero flag, 1 если получился ноль</li>
            <li>N &mdash; Negative flag, старший разряд результата (1 если результат отрицателен)</li>
        </ul>
        Флаги меняются, только если у команды был суффикс <b>S</b>, или это команда TST или CMP.
        <h2 id="suffix">Добавляемые к командам суффиксы</h2>
        Суффиксы соответствуют архитектуре ARM.<br/>
        Суффикс <b>S</b> означает, что команда долна менять флаги. Может присутствовать только у арифметических команд (кроме TST, CMP, SHL, SHR, MUL) и команд IN, OUT. Ставится после суффикса условного выполнения (при его наличии).
        <h4>Суффиксы условного выполнения</h4>
        Могут добавлены к любой команде кроме NOP, IN, OUT. Команда будет выполнена только при соответствующем условию значении флагов.
        <table>
            <tr><th>Code</th><th>Suffix</th><th>Flags condition</th><th>Description</th></tr>
            <tr><td>0000</td><td>AL</td><td>Any</td><td>Always. This suffix is normally omitted.</td></tr>
            <tr><td>0001</td><td>EQ</td><td>Z set</td><td>Equal</td></tr>
            <tr><td>0010</td><td>NE</td><td>Z clear</td><td>Not equal</td></tr>
            <tr><td>0011</td><td>CS</td><td>C set</td><td>Higher or same (unsigned &gt;= )</td></tr>
            <tr><td>0100</td><td>CC</td><td>C clear</td><td>Lower (unsigned &lt; )</td></tr>
            <tr><td>0101</td><td>MI</td><td>N set</td><td>Negative</td></tr>
            <tr><td>0110</td><td>PL</td><td>N clear</td><td>Positive or zero</td></tr>
            <tr><td>0111</td><td>VS</td><td>V set</td><td>Overflow</td></tr>
            <tr><td>1000</td><td>VC</td><td>V clear</td><td>No overflow</td></tr>
            <tr><td>1001</td><td>HI</td><td>C set and Z clear</td><td>Higher (unsigned &gt;)</td></tr>
            <tr><td>1010</td><td>LS</td><td>C clear or Z set</td><td>Lower or same (unsigned &lt;=)</td></tr>
            <tr><td>1011</td><td>GE</td><td>N and V the same</td><td>Signed &gt;=</td></tr>
            <tr><td>1100</td><td>LT</td><td>N and V differ</td><td>Signed &lt;</td></tr>
            <tr><td>1101</td><td>GT</td><td>Z clear, N and V the same</td><td>Signed &gt;</td></tr>
            <tr><td>1110</td><td>LE</td><td>Z set or (N and V differ)</td><td>Signed &lt;=</td></tr>
            <tr><td>1111</td><td></td><td></td><td>reserved</td></tr>
        </table>
        <h2 id="command_details">Форматы команд</h2>
        Все команды занимают 32 бита (2 машинных слова) и выполняются за 1 такт.<br/>
        Общий формат команды (по битам): <pre>СССС oooo o--- ---- ---- ---- ----</pre>
        <ul>
            <li>CCCC (4 бита) &mdash; условие (см. выше суффиксы условного выполнения)</li>
            <li>ooooo (5 битов) &mdash; опкод команды</li>
        </ul>
        Назначение остальных битов зависит от опкода.<br/>
        Замечания:
        <ul>
            <li>Каждая команда выполняется на всех PU одновременно.
            Если нужно выполнить только на одном - это можно сделать с помощью условного выполнения (взяв номер PU из IN_FLAGS).
            Условный переход здесь не поможет, так как счетчик команд общий для всех и управляется только из PU0.</li>
            <li>Если в PU0 был изменен один из общих регистров R8-R15, то в PU1-PU3 новое значение станет доступно только через 2 такта</li>
        </ul>
        
        <h3 id="c_NOP">NOP</h3>
            Машинный код 0x00000000. Не делает ничего. Используется для задержки между другими командами.
        <h3 id="c_arith">Арифметические команды</h3>
        Формат:
        <pre>CCCC oooo os11 aaaa bbbb rrrr i0tf 0000</pre>
        <ul>
            <li>s &mdash; 1 - менять флаги, 0 - не менять флаги</li>
            <li>aaaa &mdash; номер регистра общего назначения (при t=0) или спец. регистра (при t=1)</li>
            <li>bbbb &mdash; номер регистра общего назначения</li>
            <li>rrrr &mdash; номер регистра общего назначения (при f=0) или спец. регистра (при f=1)</li>
            <li>i &mdash; побитовое инвертирование последнего операнда</li>
        </ul>
        <i>Замечание: если на предыдущем такте (в предыдущей команде) менялось значение регистра rrrr, то будет использовано старое значение.</i><br/>
        Примеры:
        <pre>
        ADD r1, r2, r3         // r1 = r2 + r3
        ADD r1, r2, NOT r3     // r1 = r2 + ~r3
        ADDS r1, r2, r3        // выполнить сложение и изменить флаги
        ADDEQ r1, r2, r3       // выполнить сложение, если Zero flag установлен в 1
        ADDEQS r1, r2, r3      // выполнить сложение и изменить флаги, если Zero flag установлен в 1
        ADDEQ r1, r2, NOT SHIFT_RESULT       // r1 = r2 + ~SHIFT_RESULT, если Zero flag установлен в 1
        
        32 битное сложение ( MEM_RESULT_HI:MEM_RESULT_LO = r3:r4 + r5:r6 ):
        ADD MEM_RESULT_LO, r4, r6
        # если сюда вставить любую команду (даже NOP), то перенос из LO в HI не сработает
        ADC MEM_RESULT_HI, r3, r5
        </pre>
        
        Формат:
        <pre>CCCC oooo os10 aaaa bbbb iSpc cccc cccc</pre>
        <ul>
            <li>s &mdash; 1 - менять флаги, 0 - не менять флаги</li>
            <li>aaaa &mdash; номер регистра общего назначения (в примере - r1)</li>
            <li>bbbb (при p=0) &mdash; номер регистра общего назначения (в примере - r2)</li>
            <li>bbbb (при p=1) &mdash; номер спец. регистра для чтения (в примере - IN_FLAGS)</li>
            <li>ccccccccc (9 битов) &mdash; константа</li>
            <li>S &mdash; сдвиг константы на 7 битов влево</li>
            <li>i &mdash; дополнение константы 0 (при i=0) или 1 при (i=1)</li>
        </ul>
        Пример:
        <pre>
        ADDS r1, r2, 1              // r1 = r2 + 1 ; и изменение флагов
        AND r1, IN_FLAGS, 0x0f00    // r1 = IN_FLAGS & 0xf00
        Замечание: константа не может быть любой. Например можно использовать 65535 (c=511, i=1, S=0) и 1536 (c=12, i=0, S=1), но нельзя 1537.
        </pre>
        
        Формат:
        <pre>CCCC oooo os01 aaaa bbbb rrrr Gccc cccc</pre>
        <ul>
            <li>s &mdash; 1 - менять флаги, 0 - не менять флаги</li>
            <li>aaaa &mdash; номер регистра общего назначения (в примере - r1)</li>
            <li>bbbb &mdash; номер регистра общего назначения (в примере - r2)</li>
            <li>rrrr &mdash; номер регистра общего назначения для адресации в кэше (в примере - r3)</li>
            <li>ccccccc (7 битов) &mdash; смещение от 0 до 127</li>
            <li>G &mdash; 0 - все PU загружают одну ячейку, 1 - загружаются 4 соседних ячейки (ALL)</li>
        </ul>
        Пример:
        <pre>
        ADDEQ r1, r2, [r3 + 10]       // r1 = r2 + cache[r3 + 10], если Zero flag установлен в 1
        ADD r1, r2, [ALL r3 + 10]     // r1 = r2 + cache[r3 + 10]
        Замечания:
        1) Если указано ключевое слово ALL, то адрес (в этом примере r3 + 10, r3 берется из PU0) должен быть кратен четырем.
            Будут считаны 4 последовательных ячейки, каждая в свой PU.
        2) Если адресный регистр (r3) менялся в последних двух командах, то будет использовано его старое значение.
        3) Если значение в кэше было изменено в последних 3-х командах, то будет получено старое значение.
        Эти замечания актуальны для любых команд, работающих с кэшем.
        </pre>
        
        Формат:
        <pre>CCCC oooo os00 aaaa bbbb rrrr Gccc cccc</pre>
        <ul>
            <li>s &mdash; 1 - менять флаги, 0 - не менять флаги</li>
            <li>aaaa &mdash; номер регистра общего назначения (в примере - r1)</li>
            <li>bbbb &mdash; номер регистра общего назначения (в примере - r2)</li>
            <li>rrrr &mdash; номер регистра общего назначения для адресации в кэше (в примере - r3)</li>
            <li>ccccccc (7 битов) &mdash; смещение от 0 до 127</li>
            <li>G &mdash; 0 - только для PU0, 1 - для всех (ALL)</li>
        </ul>
        Пример:
        <pre>
        ADD [r3 + 10], r2, r1         // cache[r3+10] = r2 + r1, только для PU0
        ADDEQ [ALL r3 + 10], r2, r1   // cache[r3+10] = r2 + r1, для всех PU, у которых Zero flag установлен в 1
        Замечания:
        1) Если указано ключевое слово ALL, то адрес (в этом примере r3 + 10, r3 берется из PU0) должен быть кратен четырем.
            Будут записаны 4 последовательных ячейки.
        2) Если адресный регистр (r3) менялся в последних двух командах, то будет использовано его старое значение.
        3) Новое значение окажется в кэше только через 3 такта.
        </pre>
        <h3 id="c_CMP">CMP/TST</h3>
        Формат параметров и формат машинной команды эквивалентен арифметическим командам (см. выше).<br/>
        В ассемблерном представлении опускается первый параметр и не указывается суффикс S.
        В машинной команде всегда aaaa = 0000, а s = 1.<br/>
        Примеры:
        <pre>
        CMP r1, r2          // сравнить r1 с r2
        CMPEQ r8, [r3+115]  // сравнить r8 с [r3+115], если предыдущее сравнение показало равенство
        TST IN_FLAGS, 1 # проверить четность номера PU. После этого ADDEQ выполнится только на PU0 и PU2, а ADDNE только на PU1 и PU3
        </pre>
        <h3 id="c_WMUL">WMUL</h3>
        Формат параметров и формат машинной команды эквивалентен остальным арифметическим командам (см. выше).<br/>
        Значение aaaa в формате команды должно быть 2.
        <pre>
        Команда "WMUL r1, r2" произведет следующее действие:
            MUL_RESULT_LO = HI(r1 * r2) + LO(r1 * MUL_RESULT_HI)
            MUL_RESULT_HI = HI(r1 * r2)
        Умножение беззнаковое.
        Новое значение MUL_RESULT_HI будет доступно через 2 такта.
        Новое значение MUL_RESULT_LO будет доступно через 3 такта.
        </pre>
        <h3 id="c_MUL">SHL/SHR/MUL/SMUL</h3>
        Формат параметров и формат машинной команды эквивалентен остальным арифметическим командам (см. выше).<br/>
        Результат сохраняется в спец. регистры.
        <ul>
            <li>SHL/SHR &mdash; Результат доступен через такт. Запрещено инвертирование последнего операнда</li>
            <li>MUL &mdash; Беззнаковое умножение. Результат доступен через 2 такта</li>
            <li>SMUL &mdash; Умножение со знаком. Результат доступен через 2 такта</li>
        </ul>
        В ассемблерном представлении опускается первый параметр и запрещен суффикс S.
        Команды MUL, SMUL и WMUL имеют одинаковый опкод. Различие между ними происходит по битам aaaa. Для SMUL aaaa=1, для WMUL aaaa=2, в остальных случаях aaaa=0. Бит s всегда равен нулю.<br/>
        Пример:
        <pre>
        MUL r1, r2            // MUL_RESULT_HI:MUL_RESULT_LO = r1 * r2
        NOP
        NOP                   // ждем результата
        SHR MUL_RESULT_HI, 8  // сдвигаем старшие 16 бит на 8 вправо
        NOP                   // ждем результата
        SHL SHIFT_RESULT, 4   // сдвигаем на 4 влево
        </pre>
        <i>Замечание: MUL_RESULT_LO и SHIFT_RESULT &mdash; разные названия одного и того же регистра.</i>
        <h3 id="c_MOV">MOV</h3>
        Формат параметров и формат машинной команды эквивалентен арифметическим командам (см. выше).<br/>
        В ассемблерной записи второй параметр отсутствует.
        Значение bbbb должно быть или 0 или 1. Если bbbb = 1, то aaaa - не номер регистра общего назначения, а номер спец. регистра.<br/>
        Примеры:
        <pre>
            Формат команды: CCCC oooo os00 aaaa 000p rrrr Gccc cccc
        MOVS [r1 + 5], r4
        MOV [ALL r1 + 5], r4
        MOV [r1 + 5], IN_FLAGS
        
            Формат команды: CCCC oooo os01 aaaa 000p rrrr 1ccc cccc
        MOV r3, [r2+1]
        MOV OUT_LEDS, [r2]
        
            Формат команды: CCCC oooo os10 aaaa 000p is0c cccc cccc
        MOV OUT_LEDS, 7
        
            Формат команды: CCCC oooo os11 aaaa 000p rrrr i000 0000
        MOV MEM_ADDR_HI, r1
        
            Формат команды: CCCC oooo os11 aaaa 000p rrrr i001 0000
        MOV MEM_ADDR_LO, NOT SHIFT_RESULT
        MOV r2, MUL_RESULT_LO
        </pre>
        <h3 id="c_IO">IN/OUT</h3>
        Команды для работы с портами ввода-вывода. Порт имеет адрес от 0 до 15. Считывание и запись выполняются по одному байту. Команды не могут выполняться условно (код условия должен быть равен нулю). Опкод тот же, что и у MOV, разные обозначения в ассемблере введены для удобства использования. Если есть суффикс <b>S</b>, команда установит Negative flag в 0 (если операция успешна) или в 1 (если нет данных для чтения, либо переполнен буфер для записи).
        <pre>
            Формат команды: 0000 oooo os00 aaaa 0010 rrrr 0ccc cccc
            Действие: port(a) &gt;&gt; [r+c]
        IN DEV_SDRAM, [r1+1]
        INS DEV_SERIAL, [r1+2]
        
            Формат команды: 0000 oooo os01 aaaa 0011 rrrr 0ccc cccc
            Действие: port(a) &lt;&lt; [r+c]
        OUT DEV_SERIAL, [r2]
        
            Формат команды: 0000 oooo os10 aaaa 0011 0000 cccc cccc
            Действие: port(a) &lt;&lt; c
        OUT DEV_SERIAL, 'a'
        
            Формат команды: 0000 oooo os11 aaaa 0011 rrrr i000 0000
            Действие: port(a) &lt;&lt; [~]r
        OUTS DEV_SERIAL, r1
        OUT DEV_SERIAL, NOT r2
        
            Формат команды: 0000 oooo os11 aaaa 0011 rrrr i001 0000
            Действие: port(a) &lt;&lt; [~]special(r)
        OUT DEV_SERIAL, SHIFT_RESULT
        
            Формат команды: 0000 oooo os11 aaaa 0010 rrrr i000 0000
            Действие: port(r) &gt;&gt; a
        IN DEV_VGA, r1
        </pre>
        <h5>[0] Serial port (константа DEV_SERIAL)</h5>
        Взаимодействие с компьютером через последовательный порт (в Marsohod2 используется виртуальный последовательный порт при подключении платы по usb).
        Частота передачи - 6MHz (скорость порядка 500КБ/с). Для настройки соединения со стороны компьютера (решение для linux) нужно выполнить следующие команды:
        <pre>
        stty -F /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 9600 -icrnl -ixon -ixoff -opost -isig -icanon -echo cstopb
        setserial /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 spd_cust
        setserial /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 divisor 10
        stty -F /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 38400 2> /dev/null</pre>
        Буферы на прием и на передачу имеют размер по 4 байта каждый.
        <h5>[1] Sdram stats (константа DEV_SDRAM)</h5>
        Статистика загруженности канала доступа к памяти. Доступно только для чтения. При чтении по очереди выдаются два байта: процент полезной нагрузки (когда передавались данные) и процент ожидания запроса (когда память готова к работе, но запросы отсутствуют). Оба числа принимают значения от 0 (0%) до 255 (100%).
        <h5>[2] VGA control (константа DEV_VGA)</h5>
        Управление контроллером VGA. Разрешение 640x480, 60 кадров в секунду. Данные для вывода на экран берутся напрямую из оперативной памяти. Порт используется для настройки режима (графический, текстовый или комбинированный) и адреса видеопамяти.
        Если включен и текст и графика, текст отображается поверх графического изображения<br/>
        При каждом чтении выдается один байт &mdash; номер текущего кадра по модулю 256.<br/>
        Настраиваемые параметры VGA занимают 6 байт. При записи следует передавать их в порядке возрастания номера (от 0-го к 5-му). Если все 6 байтов уже записаны, следующий байт будет опять записан в 0-й байт параметров.<br/>
        Назначение параметров:
        <pre>
            Байты B0, B1 задают адрес текстового буфера. Адрес выравнивается по 256 ячеек: addr = (B1<<16)|(B0<<8)
                Каждый символ задается двумя байтами (одна ячейка) в формате:
                сссссссс rrrgggbb (по битам)
                    c - ascii код
                    r - цвет символа. красная составляющая (от 0 до 7)
                    g - цвет символа. зеленая составляющая (от 0 до 7)
                    b - цвет символа. синяя составляющая (от 0 до 3)
                Символы задаются подряд, слева направо
                Строки задаются сверху вниз. Строки должны быть выровнены по 128 ячеек.
            Байт B2: Флаги текстового режима. Если старший бит установлен, текст выключен. Другие биты не используются.
            Байты B3, B4 (если графика включена): адрес графического буфера. Выравнивается по 256 ячеек: addr = (B4<<16)|(B3<<8)
                Каждый пиксел задается двумя байтами (одна ячейка) в формате:
                rrrrrggg gggbbbbb (по битам)
                    r - цвет пиксела. красная составляющая (от 0 до 7)
                    g - цвет пиксела. зеленая составляющая (от 0 до 7)
                    b - цвет пиксела. синяя составляющая (от 0 до 3)
                Если графика выключена, то байты B3,B4 задают цвет фона (в том же формате, B3 -- младший, B4 -- старший).
            Байт B5: Флаги графического режима. Если старший бит установлен, графика выключена. Другие биты не используются.
        </pre>
        <h5>[3] Sound control (константа DEV_SOUND, не реализовано)</h5>
        <h5>[4,5] PS/2 (константы DEV_PS2_0 и DEV_PS2_1)</h5>
            Протокол PS/2. Два порта. Буфер приема имеет размер 4 байта. Буфер передачи отсутствует. После отправки каждого байта необходимо дождаться ответа от устройства прежде чем отправлять следующий байт.
        <h5>[6] USB (константа DEV_USB)</h5>
            Реализован хост-контроллер USB1.1. Поддерживаются и low-speed, и full-speed устройства.
            <p>Для передачи пакета нужно записать в порт размер пакета, учитывая PID и не учитывая CRC16 (т.е. размер может быть от 1 до 65), после чего (если не был установлен флаг <b>Z</b>, сигнализирующий о занятости порта) передать указанное количество байт. Промежутки между отправкой отдельных байтов должны составлять не более 8-и тактов. В процессе отправки тела пакета допустимо не проверять флаг <b>N</b>. Контрольные суммы CRC16 и CRC5 генерируются автоматически. SOF пакеты генерируются автоматически. Повтор отправки при отсутствии подтвержения (ACK) аппаратно не реализован. Передача нуля вместо размера пакета вызовет перезагрузку устройства (SE0 в течении 17мс) или установку флага <b>N</b>, если устройство не подключено.</p>
            <p>При чтении из порта будет получен размер пакета (если в буфере приема есть новый пакет), либо будет установлен флаг <b>N</b>, если новый пакет отсутствует. Если пакет был принят с ошибками (некорректный PID или CRC), то старший бит размера пакета будет установлен в 1. То есть считанный из порта байт окажется больше 128-и. После получения размера пакета нужно считать соответствующее количество байт. В процессе считывания тела пакета допустимо не проверять флаг <b>N</b>. CRC суммы проверяются автоматически и исключаются из пакета. ACK подтверждение для полученных пакетов данных с корректной контрольной суммой высылается автоматически.</p>
            <p>Для приема и передачи используется один и тот же буфер, поэтому при передаче пакета из буфера удаляется последний считанный пакет.</p>
        <h5>[7] reserved</h5>
        <h3 id="c_CMOV">CMOV</h3>
        Загрузка 2-байтовой константы в регистр или спец. регистр.
        <pre>
            Формат команды: CCCC oooo o000 aaaa cccc cccc cccc cccc
        Константа 'с' загружается в регистр общего назначения с номером 'а'
        Пример: CMOV r1, 0x1234
            Формат команды: CCCC oooo o001 aaaa cccc cccc cccc cccc
        Константа 'с' загружается в спец. регистр для записи с номером 'а'
        Пример: CMOV MEM_ADDR_LO, 0x1234
        </pre>
        <h3 id="c_CCMOV">CCMOV</h3>
        Загрузка 2-х байтовой константы в кэш. Выполняется только в PU0.
        <pre>
        Формат команды: CCCC oooo ommm cccc cccc rrrr cccc cccc
        Действие: cache[r+m] = c
            r - адресный регистр
            m - смещение от 0 до 7
            с - константа
        Пример: CCMOV [r15 + 2], 3600
        </pre>

        <h3 id="c_J">J/CALL/RET</h3>
        Каждая из команд перехода может иметь суффикс условного выполнения.
        После каждого перехода (даже безусловного) следующие 4 команды выполняются со старой позиции
        (сброс конвеера отключен для увеличения производительности).
        <pre>
            Формат команды: CCCC oooo o000 0000 0000 0000 0000 0000
            Действие: ip = MEM_ADDR -- переход на адрес из спец. регистра MEM_ADDR_HI:MEM_ADDR_LO
            Синтаксис в ассемблере: RET
            
            Формат команды: CCCC oooo o01c cccc cccc cccc cccc cccc
            Действие: ip += (с+4) -- относительный переход по смещению
            Синтаксис в ассемблере: J метка
            
            Формат команды: CCCC oooo o11c cccc cccc cccc cccc cccc
            Действие: MEM_ADDR = ip+5 ; ip += (c+4) -- сохранение текущего адреса в MEM_ADDR_HI:MEM_ADDR_LO и переход по смещению
            Синтаксис в ассемблере: CALL метка

            /* Пример простой функции (возведение r0 в квадрат) */
func1:      RET // Сразу выполняем команду возврата (адрес записан в MEM_ADDR). Еще 4 команды выполнятся с этой позиции.
                MUL r0, r0 // возводим в квадрат
                NOP
                NOP // ждем, пока результат запишется в MUL_RESULT
                MOV r0, MUL_RESULT_LO // копируем произведение в r0

            /* Более сложная функция с передачей параметра по ссылке через стек и сохранением адреса в стеке. Для указателя стека используется r15. */
func2:      SUB r15, r15, 2 // выделяем место в стеке под адрес
            MOV r0, [r15] // достаем параметр из стека (используется старое значение r15)
            NOP // ждем, пока новое значение r15 можно будет использовать в адресе
            MOV [r15], MEM_ADDR_LO // сохраняем адрес возврата в стек
            MOV [r15+1], MEM_ADDR_HI
            CALL func1 // вызываем вложенную функцию
                NOP
                NOP
                NOP // ожидание перехода
                NOP
            MOV MEM_ADDR_LO, [r15] // загружаем адрес из стека
            MOV MEM_ADDR_HI, [r15+1]
            MOV [r15+2], r0 // сохраняем ответ в стек на место параметра
            RET // возврат из фунции
                ADD r15, 2 // возвращаем указатель стека на место
                NOP
                NOP // ожидание перехода
                NOP
</pre>

        <h3 id="c_DJ">DJ/DCALL/DRET</h3>
        Эти команды работают аналогично J, CALL и RET, но вызывают сброс буфера команд. Формат машинной команды также аналогичен, за исключением опкода. Это единственные команды, выполнение которых занимает более 1-го такта (а именно &mdash; 5 тактов).
        <pre>
            Формат команды: CCCC oooo o000 0000 0000 0000 0000 0000
            Действие: ip = MEM_ADDR -- переход на адрес из спец. регистра MEM_ADDR_HI:MEM_ADDR_LO
            Синтаксис в ассемблере: DRET
            
            Формат команды: CCCC oooo o01c cccc cccc cccc cccc cccc
            Действие: ip += (с+1) -- относительный переход по смещению
            Синтаксис в ассемблере: DJ метка
            
            Формат команды: CCCC oooo o11c cccc cccc cccc cccc cccc
            Действие: MEM_ADDR = ip+1 ; ip += (c+1) -- сохранение текущего адреса в MEM_ADDR_HI:MEM_ADDR_LO и переход по смещению
            Синтаксис в ассемблере: DCALL метка
        
        Пример:
        команда DJ addr
        эквивалентна конструкции:
            J addr
                NOP
                NOP
                NOP
                NOP
        </pre>

        <h3 id="c_RW">READ/WRITE</h3>
        Пересылка блока данных между кэшем и оперативной памятью. Пересылка выполняется в фоновом режиме.
        Если новая пересылка запущена до завершение предыдущей, то предыдущая останавливается.
        Убедиться, что предыдущая пересылка завершилась, можно по значению <a href="#in_flags">флага "m"</a>.<br/>
        <i>Замечание: В следующей команде после старта операции флаг "m" еще не успеет измениться в 1.</i><br/>
        Пересылка запускается только из PU0. Начальное значение адреса в оперативной памяти берется из спец. регистров MEM_ADDR_HI:MEM_ADDR_LO.
        <pre>
        Формат команды: CCCC oooo ow01 0000 bbbb rrrr 0ccc cccc
            w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
            bbbb -- начальный адрес в кэше
            rrrr и ссссссс -- адресный регистр и смещение, по которому в кэше хранится количество ячеек в блоке
        Пример: READ r8, [r1+2] // Взять [r1+2] ячеек из оперативной памяти, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO и записать начиная с адреса r8 в кэше
        
        Формат команды: CCCC oooo ow10 0000 bbbb iS0c cccc cccc
            w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
            bbbb -- начальный адрес в кэше
            ccссссссс -- константа (размер блока)
            S -- сдвиг константы на 7 битов влево
            i -- дополнение константы нулями (i=0) или единицами (i=1)
        Пример:
            CMOV r8, 0
            WRITE r8, 16384 // Всё содержимое кэша записать в оперативную память, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO
        
        Формат команды: CCCC oooo ow11 0000 bbbb rrrr i00p 0000
            w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
            bbbb -- начальный адрес в кэше
            rrrr -- номер регистра (при p=0) или спец. регистра (при p=1) (размер блока)
            i -- побитовое инвертирование rrrr (при i=1)
        Примеры:
            READ r8, r1 // Взять r1 ячеек из оперативной памяти, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO и записать начиная с адреса r8 в кэше
            WRITE r8, MUL_RESULT_LO
            WRITE r8, NOT SHIFT_RESULT
        </pre>
        <!--<h3 id="c_FPU">FPMODE/FPDATA/FPGET</h3>
        Блоки FPU отключены.
        <i>Этот раздел не завершен</i>
        <pre>
            mode: SAABB
                S 0/1 -> +/-
                AA
                    00 +-  CL 7
                    01 *   CL 5
                    10 /   CL 14    (только PU0/PU1)
                    11 reserved
                BB
                    00 AA
                    01 int -> float: p2 + p1 * 2**-16   CL 6
                    10 (int)AA                          CL +6
                    11 (int)(AA*256)                    CL +6
                
            FPMODE CONVERT      //                   BB = 01
            FPMODE FADD         // S = 0,  AA = 00,  BB = 00
            FPMODE FSUB, FLOOR  // S = 1,  AA = 00,  BB = 10
            FPMODE FMUL, FIXED  //         AA = 01,  BB = 11
            FPMODE FDIV         //         AA = 10,  BB = 00
            
            FPDATA r2, [r3+16]
            FPGET [ALL r3], r2, r4
        </pre>-->
        <h2 id="asm">Синтаксис ассемблера</h2>
        Комментарии задаются в стиле Си. До конца строки &mdash; "//", Несколько строк &mdash; "/* ... */".
        <h3>Константы</h3>
        <pre>
        1) Десятичные числа. Пример: -57
        2) Шеснадцатиричные числа. Пример: 0x120
        3) Символы. Пример: 'a'
        4) Для чисел, не помещающихся в два байта (одна ячейка):
            LO(65538)       - 2 (младшие два байта)
            HI(65538)       - 1 (старшие два байта)
            LO(1.0)         - 0x0000 (младшие два байта)
            HI(1.0)         - 0x3f80 (старшие два байта)
            Для float указание десятичной точки обязательно
        5) Цвет: RGB("R G B")
            R, G, B -- целые числа от 0 до 31
        Предопределенные константы:
        DEV_SERIAL = 0      - номер I/O порта Serial
        DEV_SDRAM = 1       - номер I/O порта для получения статистики использования sdram
        DEV_VGA = 2         - номер I/O порта контроллера VGA
        N_FLAG  = 16        - маска флага N в регистре IN_FLAGS
        Z_FLAG = 32         - маска флага Z в регистре IN_FLAGS
        V_FLAG = 64         - маска флага V в регистре IN_FLAGS
        C_FLAG = 128        - маска флага C в регистре IN_FLAGS
        SOFTKEY_FLAG = 4    - маска флага b (нажатие кнопки на плате) в регистре IN_FLAGS
        MEM_FLAG = 8        - маска флага m (выполнение операции с sdram в данный момент) в регистре IN_FLAGS
        </pre>
        Константные выражения могут использовать операции +, -, *, /, %, &, |, ^, ~, <<, >> и скобки.
        <h3>Метки и адреса</h3>
        Метки указываются в начале строки. После имени метки ставится двоеточие. Все вхождения метки в программе будут заменены на её значение.<br/>
        <ul>
            <li>.code maddr raddr &mdash; сегмент команд. maddr -- точка отсчета для меток, raddr -- физический адрес сегмента в выходном файле. Сегменты должны быть описаны в том же порядке, в котором будут находиться в выходном файле.</li>
            <li>.data maddr raddr &mdash; работает в точности также, как и .code; рекомендуется использовать для сегментов данных.</li>
            <li>.virtual maddr &mdash; сегмент неинициализированных данных.</li>
            <li>.words ЧИСЛО &mdash; неинициализированные данные (увеличение смещения на указанное число)</li>
            <li>.ascii "STRING" &mdash; строковая константа; два символа в слове; при нечетном количестве символов дополняется нулем; заканчивается нулевым словом</li>
            <li>.const ЧИСЛО, ЧИСЛО, ЧИСЛО, ... &mdash; константы</li>
        </ul>
        Пример:
        <pre>
    .code 0x0 0x0
            MOV r0, 0
            MOV r1, 5
            MOV r2, 7
            CMOV [r0 + var_a], r1
            CMOV [r0 + var_b], r2
            .const 0x0000, 0x0000 // Эквивалентно команде NOP
    .offset 0x0 0x100
var_a:      .words 1
var_b:      .words 1
        </pre>
        <h3>Препроцессор</h3>
        Используется препроцессор Си. Комментарии указываются в стиле Си.<br/>
        Дополнительно добавлены макросы в следующем формате:
        <pre>
        .macro some_name // объявление макроса some_name без параметров
$(m)_loop:  J $(m)_loop  // бесконечный цикл
                NOP
                NOP
                NOP
                NOP
        .endmacro
        .macro swap p1, p2 // макрос с параметрами
            MOV r0, p2
            MOV p2, p1
            MOV p1, r0
        .endmacro
        some_name // вызов макроса без параметров
        swap r5, r7 // вызов макроса с параметрами
        </pre>
        Вместо "$(m)" при подстановке макроса будет вставлен уникальный номер. Таким образом метка, начинающаяся с "$(m)", будет уникальна даже при использовании одного макроса несколько раз.
        <h2 id="bootloader">Загрузчик</h2>
        После включения питания загрузчик пытается считать программу через последовательный порт или через USB. Считанные данные загружаются в оперативную память, начиная с адреса 0x100000 (т.е. с 3-го мегабайта). Если проверка контрольной суммы успешна, выполняется переход на адрес 0x100000. Загрузчик хранится в ПЗУ на 2кб (256 команд). Ему соответствуют адреса 0x0 - 0x200, однако при чтении из оперативной памяти командами READ и WRITE ПЗУ не задействуется. Т.е. тот же диапазон адресов 0x0 - 0x200 можно использовать для хранения данных. Но при передаче управления на адрес из этого диапазона, будет выполнен код из ПЗУ. В ПЗУ, помимо загрузчика, содержатся следующие функции: отправка USB Request, деление с остатком, перевод числа в строку и функция форматированного вывода. Их описания и адреса находятся в файле include/std.H.
        <h4>Загрузка через последовательный порт</h4>
        <h4>Загрузка через USB</h4>
        <h2 id="details">Некоторые особенности</h2>
        <ul>
            <li>После перехода командами J, CALL или RET выполняется 4 команды со старой позиции. Если такое поведение нежелательно, используйте команды DJ, DCALL, DRET.</li>
            <li>Если регистр менялся в последних двух командах, то при использовании в адресе будет взято старое значение</li>
            <li>Если значение в кэше было изменено в последних 3-х командах, то при чтении будет получено старое значение</li>
            <li>ADC, RSC, SBC используют перенос предыдущей команды, даже если эта команда не сохраняла флаги</li>
            <li>Между обращениями к разным устройствам ввода-вывода должно пройти не менее 3-х тактов</li>
            <li>IN и OUT не могут иметь суффикс условного выполнения</li>
            <li>Если в PU0 был изменен один из общих регистров R8-R15, то в PU1-PU3 новое значение станет доступно только через 2 такта.
                <pre>
                    Пример:
                    TST IN_FLAGS, 1
                    CMOVEQ r0, 1
                    CMOVNE r0, 2
                    MOV r8, r0
                    NOP
                    MOV r1, r8 // в PU0 и PU2 будет r1=1, в PU1 и PU3 -- r1=2
                    MOV r2, r8 // во всех PU   r2=1
                </pre>
            </li>
            <li>Команды SHL, SHR не меняют флаги и для них не работает инвертирование второго операнда. Результат доступен в спец. регистре через такт.</li>
            <li>Команды MUL, SMUL не меняют флаги. Результат доступен в спец. регистрах через 2 такта.</li>
            <li>Команда WMUL не меняет флаги. Результат доступен в спец. регистрах через 3 такта.</li>
            <li>Изменение любого спец. регистра вступает в силу только через один такт (должна быть как минимум одна команда между изменением и использованием).</li>
            <li>В следующем такте после операции READ или WRITE флаг "m", указывающий на выполняющуюся операцию с памятью, еще не установлен.</li>
            <li>В арифметических командах если последний параметр &mdash; регистр, измененный в предыдущей команде, то будет использовано старое значение.</li>
        </ul>
        
        <h2 id="examples">Примеры программ</h2>
        <hr/>
        <pre>
// timer.S
// Меняет состояние светодиодов два раза в секунду
.code 0x0
l:          J l
            SHR IN_TIME_MS4, 11
            NOP
            MOV OUT_LEDS, SHIFT_RESULT
            NOP
        </pre>
        <hr/>
        <pre>
// serial.S
// Возвращает полученные через последовательный порт байты
// Меняет состояние светодиодов при удержании кнопки на плате
.code 0x0
            CMOV r0, SOFTKEY_FLAG
l:          INS DEV_SERIAL, r1
            JMI l
                TST r0, IN_FLAGS
                CMOVEQ OUT_LEDS, 10
                CMOVNE OUT_LEDS, 5
                NOP
            OUT DEV_SERIAL, r1
            DJ l
        </pre>
        <hr/>
        <pre>
// pu_sum.S
// Считает сумму номеров всех PU и выводит на светодиоды
.code 0x0
            MOV r15, 0
            NOP
            AND r0, IN_FLAGS, 3
            MOV [ALL r15], r0
            NOP
            NOP
            NOP
            ADD r1, r15, [r15]
            ADD r1, r1, [r15+1]
            ADD r1, r1, [r15+2]
            ADD r1, r1, [r15+3]
            MOV OUT_LEDS, r1
end:        DJ end
        </pre>
        <hr/>
        <pre>
// rhomb.S
// Заполняет экран цветными ромбиками
#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define X r0
#define Y r14
#define tmp r1
#define mem_lo r12
#define mem_hi r13
#define COLOR r2
#define SCREEN_WIDTH_S4 r11
.code 0x0
            OUT DEV_VGA, 0
            OUT DEV_VGA, 0
            OUT DEV_VGA, 128
            OUT DEV_VGA, 0
            OUT DEV_VGA, 0
            OUT DEV_VGA, 0
            CMOV mem_lo, 0
            CMOV mem_hi, 0
            CMOV SCREEN_WIDTH_S4, SCREEN_WIDTH-4
            CMOV Y, 0
loop_y:     AND X, IN_FLAGS, 3
loop_x:     ADD tmp, X, Y
            TST tmp, 16
            CMOVEQ COLOR, 0
            CMOVNE COLOR, 0xf800
            SUB tmp, X, Y
            CMP X, SCREEN_WIDTH_S4
            JNE loop_x
                TST tmp, 16
                ORNE COLOR, COLOR, 0x1f
                MOV [ALL X], COLOR
                ADD X, X, 4
            ADD mem_lo, mem_lo, SCREEN_WIDTH
            ADC mem_hi, mem_hi, 0
            MOV MEM_ADDR_LO, mem_lo
            MOV MEM_ADDR_HI, mem_hi
            CMOV tmp, 0
            TST IN_FLAGS, MEM_FLAG
wait_mem:   JNE wait_mem
                WRITEEQ tmp, SCREEN_WIDTH
                CMPEQ Y, SCREEN_HEIGHT-1
                JMI loop_y
                TST IN_FLAGS, MEM_FLAG
                ADD Y, Y, 1
                NOP
                NOP
end:        DJ end
        </pre>
    </body>
</html>

